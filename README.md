Global UPI Multi-Agent System: An Interactive Financial Agent
Welcome to the Global UPI Multi-Agent System, a sophisticated financial platform powered by an interactive AI agent. This is not just a script that runs and stops; it's a persistent, intelligent entity that leverages a dynamic knowledge graph and the vast Agentverse network to execute complex cross-border transactions in the most efficient way possible.

Core Concepts: The Brain of the Agent
This system is built on three cutting-edge AI principles that allow it to reason, adapt, and delegate tasks intelligently.

1. The Dynamic Knowledge Graph (MeTTa)
At the heart of our Financial Agent is a MeTTa-based knowledge graph. Think of this as the agent's real-time memory. Instead of relying on hardcoded or stale information, the agent constantly updates this graph with fresh data.

How it works: When the agent uses its fetch_and_update_realtime_rates tool, it doesn't just get a number; it asserts a new fact into its knowledge graph, like (has-rate INR ETH 0.0000035).

Why it's better: When the AI planner needs to make a decision, it queries this internal graph. This ensures that every calculation and transaction path is based on the most current market conditions, allowing it to "predict better" and find the genuinely cheapest route for the user.

2. Dynamic Agent Discovery in the Agentverse
Our Financial Agent is not alone. It is part of the vast Agentverse, a network of countless specialized agents. Using its discover_expert_agent tool, our agent can find and communicate with any other agent registered on the network.

How it works: If a user asks a complex question that is outside the scope of finance (e.g., "What are the market sentiments around blockchain tech today?"), our agent can delegate this task. It sends a query to the Agentverse to find an "Expert Market Analyst Agent," gets the information, and then integrates that knowledge into its financial plan.

Why it's powerful: This makes our system infinitely extensible. It can dynamically "generate" new capabilities by collaborating with other agents, ensuring it always has the best tool or expert for any given job without needing to be reprogrammed.

3. The AI Planner (ASI:One)
The "brain" that orchestrates everything is the ASI:One model. It receives the user's high-level goal (e.g., "Pay $1200 to a US merchant") and, by looking at all the available tools and the current state of the knowledge graph, it creates a complex, multi-step plan from scratch to achieve it. This plan is what you see being executed turn-by-turn in the console.

System Architecture
The system is built on a modular, two-agent design that separates responsibilities for scalability and clarity:

Primary Agent (The Router): The public-facing gateway that receives user requests via a webhook, discovers the Financial Agent, and manages the asynchronous response polling.

Financial Agent (The Specialist): The core workhorse that is not publicly exposed. It houses all the specialized tools, manages the knowledge graph, and executes the complex plans generated by the AI planner.

Setup Instructions
Follow these steps to get the agent system running locally.

1. Prerequisites
Python 3.10+

An active ASI:One API Key.

2. Create the Environment File
Create a file named .env in the root of the project directory and populate it with your credentials and pool addresses:

ASI_ONE_API_KEY="your_asi_one_api_key_here"

# Your system's operational wallet/account addresses
INDIAN_BANK_POOL="your_indian_bank_account_or_wallet"
INDIAN_CRYPTO_POOL="your_indian_crypto_pool_wallet_address"
USA_CRYPTO_POOL="your_usa_crypto_pool_wallet_address"
USA_USD_ACCOUNT="your_usa_bank_account_for_payouts"

3. Install Dependencies
Install all the required Python packages using the requirements.txt file:

pip install -r requirements.txt

Running the Agent System
To start the Bureau and run both agents, execute the main script:

python agent.py

The console will confirm that both agents are running and provide the webhook URL for interaction.

How to Interact with the System
The system uses an asynchronous polling flow, which is standard for complex, long-running agent tasks.

You just need to Run the agent and say in natural language what you want to do!!!

